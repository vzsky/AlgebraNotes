% chktex-file 44
% chktex-file 8

\documentclass{article}
\input{../texheaders/preamble}
\input{../texheaders/macros}

\fancyhead[L]{Category Theory}
\fancyhead[R]{note by \textbf{Touch Sungkawichai}}

\newcommand{\C}{\mathcal C}
\newcommand{\D}{\mathcal D}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\ob}{ob}
\DeclareMathOperator{\Func}{Func}

\newcommand{\Type}{\textbf{Type} }

\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

Many people might have heard about category theory before as the most pure or abstract branch of mathematics.
I tried to learn category theory a few times and failed all of them. There are a lot of ways one can approach category 
theory and at least from mathematical standpoint and functional programming standpoint, the connection is very loose.

First, I must say that category theory is a generalization of math. To understand a generalization of something, you 
first need a lot of example of those something. You will not understand addition if you didn't realize first that 3 apples plus 3 apples give
similar result as 3 bananas plus 3 bananas. You will not understand group unless you realize that addition and multiplication behaves 
similarly. In the same way, you will not understand category if you don't understand what group homomorphism, function, and topological homeomorphism
have in common. I pick these three because it is to me the easiest one. The point is premature generalization is bad, and so is 
learning category theory without enough example.

\section{Definition}
Let's start easy. I'll be sloppy and disregard all bullshits on the size of set and classes. 
A category is a collection of objects and arrows. 
Let $\C$ be a category. We usually write $A, B$ for objects and $f, g, h$ for arrows.

Arrows point from one object to another.
Arrows will also compose and be associative. 
That means if there are arrows $f, g$, there will be arrow $f \circ g$ and $(f \circ g) \circ h = f \circ (g \circ h)$.
There will always be identity arrows pointing from an object to itself.

We then define $\ob(\C)$ to be the set of all objects in $\C$ and $\Hom_\C(A, B)$ as the set of all arrows 
from $A$ to $B$ in category $\C$.

\subsection{Example (sloppy)}
\begin{itemize}
  \item \textbf{A category of sets: } objects are all sets, arrows are function between one set to another.  
  \item \textbf{A category of groups: } objects are all groups, arrows are group homomorphisms.
  \item \textbf{A category of topologies: } objects are all top spaces, arrows are homeomorphisms.
\end{itemize}

Note that we can define a category of groups so that objects are all groups and arrows are function between the underlying set to another.
This is a valid category but not a useful one since it's very similar to the category of set.

When $f: A \to B$ and $g: B \to A$ both exist in a category, the object $A$ and $B$ will be very similar. They are isomorphism.
For example, if there is a function from set $S$ to set $T$ and also from $T$ to $S$, then the two set has the same size. If there is 
a homomorphism from group $G$ to $H$, then the two groups are isomorphism.

\subsection{More Example}
\begin{itemize}
  \item \textbf{0: } A trivial category with no object, hence no arrows.
  \item \textbf{1: } A category with one object and 1 identity arrow.
  \item \textbf{2: } A category with two objects, 2 identity arrows and 1 arrow from one object to the other.
\end{itemize}

\exc{}{ 
  There is a \textit{unique} category with 3 objects (with no isomorphic objects). Describe it.
}

\section{Functor}
Functors are the morphism of category. Functor $F$ maps each object $A$ to $F(A)$ and maps each arrow $f$ to $F(f)$ so it's possible to 
think of a functor as two functions tied together, one is the object function and the other is the arrow function.

Like group homomorphism, not all mapping is a functor. If there are objects $A, B \in \C$ and let the result category be $\D := F(\C)$, 
then $F(A), F(B)$ needs to be in $\D$. If there is an arrow $f: A \to B$ then $F(f)$ must be from $F(A) \to F(B)$.

\rem{Functor is overloaded}{
  $F$ is overloadded with 3 meanings now: $F(\C)$ is a category when $\C$ is a category, 
  $F(A)$ is an object in $F(\C)$ when $A$ is an object in $\C$ and $F(f)$ is an arrow in $F(\C)$ when $f$ is an arrow in $\C$. 
}

\subsection{Example}
\begin{itemize}
  \item $\Func(\textbf{1},\C)$ \textit{corresponds} to the $\ob(\C)$.
    Since \textbf{1} has only one object, the object map will send that element to any object of $\C$. 
    This means that picking any $A \in \ob(\C)$, there is a corresponding functor $F_A: O_1 \mapsto A$ and picking 
    any $F \in \Func(\textbf{1}, \C)$, there is a corresponding object $F(O_1)$ in $\C$.

  \item $\Func(\textbf{2},\C)$ \textit{corresponds} to the set $\set{\text{arrow } f \text{ in }\C}$.
    Similarly when picking any arrow $f: A \to B$ from $\C$, there is a corresponding functor $F_f$ such that 
    \eqs{
      F_f:& \textbf{2} \mapsto \C & \text{ as category }\\
      F_f:& O_1 \mapsto A & \text{ as object } \\
      F_f:& O_2 \mapsto B & \text{ as object } \\
      F_f:& (O_1 \mapsto O_2) \mapsto f & \text{ as arrow }\\
    }
    Where $O_1$ and $O_2$ are two objects in $\textbf{2}$

    Picking any functor $F$ from $\Func(\textbf{2}, \C)$, there is also a corresponding arrow $F(O_1 \mapsto O_2)$.

\end{itemize}

\exc{}{ 
  Show that the functors from $\textbf{3}$ to $\C$ corresponds to all pairs of arrows in $\C$ that compose.
}

\subsection{More examples}
\begin{itemize}
  \item Forgetful functor $F$ that sends any group $G$ to the underlying set $G$ is a functor from the category of groups to the category 
    of sets.
  \item Powerset is a functor from the category of sets to itself.
\end{itemize}

\section{For Programmers}
For programmers, I recommend the book \textbf{Category Theory for Programmers} by Bartosz Milewski. It is an easy enough read. 
Some of the content here will be based on the book. 
I'm not trying to replace that (as it's impossible to) but this section will be mainly my intepretation, i.e. can be wrong, 
and would be more like a note / summary on how I understand things.

In context of programming. The \textit{only (for the most part)} category we care about is the category of types, write $\Type$. 
The objects of $\Type$ are all posible types such as \code{bool}, \code{int}, or \code{char} but also includes more complex types 
such as \code{list<int>}.

Type is like set as it holds multiple possible values. \code{bool} can be thought of as a set $\set{\code{true}, \code{false}}$ and \code{int}
can be thought of as the set of all integers for example.

The arrow in the category of type is all the functions from one type to another. For example a function $\code{isPrime}$ is an arrow from 
\code{int} to \code{bool} or a function \code{square} is an arrow from \code{int} to \code{int}. A function needs to be pure. 
It needs to have no side effect, i.e. not modifier anything outside of the function scope.

Confusingly or not, a function type like \code{int $\to$ bool} is a type, therefore is an object. 
However, a member of \code{int $\to$ bool} such as \code{isPrime} is an arrow. 
This is similar to \textbf{Set} as a set of functions is an object while a function is an arrow.

\subsection{Functor}
Since we only care about the category of type. The only functor we care about is the functor from \Type to \Type.
Therefore, in this section all functor will be from \Type to \Type (as category) and we only need to say 2 things about a functor: 
how it maps the objects (a type) and how it maps the arrows (a function).
Obviously there is an identity functor, but there are many more.

\begin{itemize}
  \item \code{optional} is a functor (from \Type to \Type). 
    \begin{verbatim}
      template<typename T>
      class optional<T> {
        bool has_value = false;
        T value;
        optional () { has_value = false; value = {}; }
        optional (T v) { has_value = true; value = v; }
      };
    \end{verbatim}
    It send a type \code{T} to a new type \code{optional<T>}. 
    How? given a value \code{x} of type \code{T}, we can have a value \code{optional<T> (x)}; 
    For each arrow $f: T \to S$, we have corresponding $\code{optional<$f$>}:\code{optional<$T$>} \to \code{optional<$S$>}$.
    such that it operates on the underlying value. We can define the function as 
    \begin{verbatim}
      auto optional_map (Function f) {
        return [](optional<T> o) {
          if (!o.has_value) return optional<S> (false);
          return optional<S> (true, f(o.value));
        };
      }
    \end{verbatim}
    A bit ugly to try to fit this to C++ (I'm aware it will not compile).
  \item \code{list} is another example. It maps object \code{T} to \code{list<T>} by simply make it a list. 
    That means we can make a list of one element \code{[x]} when we have an element \code{x}. 
    The functor also transform arrow. The way it does this is from \code{f: T $\to$ S} we have an arrow 
    \code{list<T> $\to$ list<S>} that does the same thing to every element in the list.
\end{itemize}

\end{document}
