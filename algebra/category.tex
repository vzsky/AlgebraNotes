% chktex-file 44
% chktex-file 8

\documentclass{article}
\input{../texheaders/preamble}
\input{../texheaders/macros}

\usepackage{float}

\fancyhead[L]{Category Theory}
\fancyhead[R]{note by \textbf{Touch Sungkawichai}}

\newcommand{\C}{\mathcal C}
\newcommand{\D}{\mathcal D}
\newcommand{\op}{\text{op}}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\ob}{ob}
\DeclareMathOperator{\Func}{Func}
\DeclareMathOperator{\Nattran}{Nat}

\newcommand{\Type}{\textbf{Type} }
\newcommand{\Set}{\textbf{Set} }

\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

Many people might have heard about category theory before as the most pure or abstract branch of mathematics.
I tried to learn category theory a few times and failed all of them. There are a lot of ways one can approach category 
theory and at least from mathematical standpoint and functional programming standpoint, the connection is very loose.

First, I must say that category theory is a generalization of math. To understand a generalization of something, you 
first need a lot of example of those something. You will not understand addition if you didn't realize first that 3 apples plus 3 apples give
similar result as 3 bananas plus 3 bananas. You will not understand group unless you realize that addition and multiplication behaves 
similarly. In the same way, you will not understand category if you don't understand what group homomorphism, function, and topological homeomorphism
have in common. I pick these three because it is to me the easiest one. The point is premature generalization is bad, and so is 
learning category theory without enough example.

\section{Category}
\df{Category}{
  Let's start easy. I'll be sloppy and disregard all bullshits on the size of set and classes. 
  A category is a collection of objects and arrows. 
  Let $\C$ be a category. We usually write $A, B$ for objects and $f, g, h$ for arrows.

  Arrows point from one object to another.
  Arrows will also compose and be associative. 
  That means if there are arrows $f, g$, there will be arrow $f \circ g$ and $(f \circ g) \circ h = f \circ (g \circ h)$.
  There will always be identity arrows pointing from an object to itself.

  We then define $\ob(\C)$ to be the set of all objects in $\C$ and $\Hom_\C(A, B)$ as the set of all arrows 
  from $A$ to $B$ in category $\C$.
}

\exmp{Example (sloppy)}
{
  \begin{itemize}
    \item \textbf{A category of sets: } objects are all sets, arrows are function between one set to another.  
    \item \textbf{A category of groups: } objects are all groups, arrows are group homomorphisms.
    \item \textbf{A category of topologies: } objects are all top spaces, arrows are continuous continuous functions.
  \end{itemize}
}

Note that we can define a category of groups so that objects are all groups and arrows are function between the underlying set to another.
This is a valid category but not a useful one since it's very similar to the category of set.

Arrows $f: A \to B$ and $g: B \to A$ can both exist in a category without meaning anything. However, 
if $f: A \to B$ and $g: B \to A$ exists such that $fg = 1_B$ and $gf = 1_A$, then the object $A$ and $B$ will be very similar. 
They are isomorphism.
For example, if there are such functions from set $S$ to set $T$ and vice versa, then the two set has the same size. Or if there 
is such continuous maps between two topological spaces, they are homeomorphic.

\exmp{More small examples}
{
  \begin{itemize}
    \item \textbf{0: } A category with no object, hence no arrows.
    \item \textbf{1: } A category with one object and 1 identity arrow.
    \item \textbf{2: } A category with two objects, 2 identity arrows and 1 arrow from one object to the other.
  \end{itemize}
}

A lot of things are categories. If I want a category where objects are integers. I can do that by defining so with 
no arrows (except for identity). That is a valid (but not useful) category. I can also draw arrows between all pairs 
of integers, that is again valid, but not useful. I can draw arrows from $a \to b$ whenever $a \le b$. That is valid, 
and can be a little more useful. I can also draw arrows from $a \to b$ whenever $a \vert b$ and that will be just a little 
more interesting.

Another interesting category is
\df{Dual Category}{
  Dual category of $\C$ is written $\C^\op$ has the same object as $\C$ but the direction of all arrows are swapped. 
}

\section{Functor}
\df{Functor}{
  Functors are the morphism between categories. Functor $F$ maps each object $A$ to $F(A)$ and maps each arrow $f$ to $F(f)$ so it's possible to 
  think of a functor as two functions tied together, one is the object function and the other is the arrow function.
}

Like group homomorphism, not all mapping is a functor. If there are objects $A, B \in \C$ and let the result category be $\D$. 
Let $F$ be a functor from $\C$ to $\D$. then $F(A), F(B)$ needs to be in $\D$ by definition. 
If there is an arrow $f: A \to B$ then $F(f)$ must be from $F(A) \to F(B)$.

\rem{Functor is overloaded}{
  $F$ is overloadded with 3 meanings now: $F(\C)$ is a category when $\C$ is a category, 
  $F(A)$ is an object in $F(\C)$ when $A$ is an object in $\C$ and $F(f)$ is an arrow in $F(\C)$ when $f$ is an arrow in $\C$. 
}

\exmp{Example}
{
  \begin{itemize}
    \item $\Func(\textbf{1},\C)$ \textit{corresponds} to the $\ob(\C)$.
      Since \textbf{1} has only one object, the object map will send that element to any object of $\C$. 
      This means that picking any $A \in \ob(\C)$, there is a corresponding functor $F_A: O_1 \mapsto A$ and picking 
      any $F \in \Func(\textbf{1}, \C)$, there is a corresponding object $F(O_1)$ in $\C$.

    \item $\Func(\textbf{2},\C)$ \textit{corresponds} to the set $\set{\text{arrow } f \text{ in }\C}$.
      Similarly when picking any arrow $f: A \to B$ from $\C$, there is a corresponding functor $F_f$ such that 
      \eqs{
        F_f:& \quad \textbf{2} \mapsto \C & \text{ as category }\\
        F_f:& \quad O_1 \mapsto A & \text{ as object } \\
        F_f:& \quad O_2 \mapsto B & \text{ as object } \\
        F_f:& \quad (O_1 \mapsto O_2) \mapsto f & \text{ as arrow }\\
      }
      Where $O_1$ and $O_2$ are two objects in $\textbf{2}$
      Picking any functor $F$ from $\Func(\textbf{2}, \C)$, there is also a corresponding arrow $F(O_1 \mapsto O_2)$.
    \item Forgetful functor $F$ that sends any group $G$ to the underlying set $G$ is a functor from the category of groups to the category 
      of sets.
  \end{itemize}
}

\subsection{Contravariant functors}
\df{Contravariant functors}{
  A contravariant functor from $\C$ to $\D$ is a covariant functor from $\C^{op}$ to $\D$
}

Another way to say that is that contravariant functor is defined similarly to functor with a twist. 
$F$ is a contravariant functor from $\C$ to $\D$ if it sends an object 
from $\ob(\C)$ to $\ob(\D)$ and for each arrow $f: A \to B$, the result is $F(f): F(B) \to F(A)$. 

The only different is that the order of arrow switch in the resulting category.

Then there is one obvious example of contravariant functor, the dual functor. 
\eqs{
  F:& \quad \C \mapsto \C^\op & \text{as category} \\
  F:& \quad A \mapsto A  & \text{as object} \\
  F:& \quad (A \mapsto B) \mapsto (B \mapsto A)  & \text{as arrow} \\
}

\subsection{Hom Functors}
Hom functor is a tricky functor that is interesting and very important.
We have defined earlier that in a fixed category $\C$, $\Hom_\C(A, B)$ or sometimes just $\Hom(A, B)$ is the set 
of all arrows from $A$ to $B$.

Now, we can define $h_A(X) = \Hom(A, X)$ so that $h_A$ is a function that receive an object and returns a set. 
Moreover, let $f$ be an arrow in $\C$ from $X$ to $Y$ and define $h_A(f)$ to be a function from $h_A(X)$ to $h_A(Y)$.

Before actually defining those $h_A(f)$, let's see what we have. 

We have $A$, $X$, and $Y$ as objects in $\C$. We have $h_A(X)$ as the set of all arrows from $A$ to $X$ and 
similarly $f_A(Y)$ is the set of all arrows from $A$ to $Y$. What we know from the fact that $\C$ is a 
category is that if we have an arrow from $X$ to $Y$, then composition of something in $h_A(X)$ with the arrow will give 
us something in $h_A(Y)$.

So we can define the function that way. Formally, 
\eqs{
  h_A(f):& &\Hom(A, X) &\to \Hom(A, Y) \\ 
  & &a &\mapsto f \circ a
}

Now, as $h_A$ maps the object in $\C$ to a set and map arrows in $\C$ to a function (in an appropriate way), 
we know that it is a functor.

That was half the things. The other half is we also have $h_A^\op$ defined as $h_A^\op(X) = \Hom(X, A)$ and $h_A^\op(f) = (a \mapsto a \circ f)$. 
This half is not a functor from $\C$ to $\Set$ but it is from $\C^\op$ to $\Set$. In other words, it is a contravariant functor from 
$\C$ to $\Set$.

I personally don't like the notation $h_A$ and $h_A^\op$ because it can be confusing sometimes. I find $\Hom(A, -)$ and $\Hom(-, A)$ 
more intuitive. Be careful that with this notation, for any arrow $f: X \to Y$, $\Hom(A, f)$ would be an arrow 
in \Set from $\Hom(A, X)$ to $\Hom(A, Y)$ as defined earlier.

\section{Natural Transformation}
Natural Transformation is the first tricky bit of category theory. I thought I understand what it is a few time before 
actually understand what it is. 

First thing you need to understand is the infamous phrase \textbf{\textit{diagram commutes}}. 
\df{Diagram Commutes}{
  It is said that a diagram commutes when the diagram is nice.
  i.e. all directed paths with the same start and end give the same morphism.
}

A natural transformation $\eta$ between two functors $F, G: \C \to \D$ is such that the following diagram commutes.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{nattrans.png}
\end{figure}

A natural transformation from $F: \C \to \D$ to $G: \C \to \D$ is induces (or is defined for) $\eta_A$ for all objects $A \in \C$.
$\eta_A$ shows how to turn $F(A)$ to $G(A)$ in a way that respects the arrow map of $F$ and $G$.

Again, a natural transformation $\eta$ specifies how to turn $F(A)$ to $G(A)$ for all $A$. Therefore if we want to define a 
natural transformation, one way is to define $\eta_A$ for all $A$.

\rem{}{
  I used to mistake natural transformation as functor of functor but it is not really so. A functor maps both objects and arrows but 
  a natural transformation only care about mapping $F(\_)$ to $G(\_)$.
}

\rem{}{
  The blue arrow in the diagram is the induced natural transformation. That means it shows how $\eta$ maps object 
  of $F(A)$ to $F(B)$. It might not be an arrow in $\D$.
}

With natural transformation, we can construct a category of functor $\Func(\C, \D)$ where is objects are all functor from 
$\C$ to $\D$ and the arrow from $F$ to $G$ exists for each natural transformation of $F$ and $G$.

Now, we denote $\Nattran(F, G)$ as the set of all natural transformations from $F$ to $G$. In other words, 
\[ \Nattran(F, G) = \Hom_{\Func(\C, \D)}(F, G) \] given that $F, G$ are functors from $\C$ to $\D$.

\section{Yoneda Lemma}

Let $F$ be any functor from $\C$ to $\Set$. Notice that $\Hom(A, -)$ is also a functor from $\C$ to $\Set$. The surprising thing 
will want to show now is that $F(A)$ \textit{corresponds} to $\Nattran(\Hom(A, -), F)$.

Specifically, we want to show that there is a one to one relationship between $F(A)$ and $\Nattran(\Hom(A, -), F)$.
That is for any element $u$ of $F(A)$, there is a unique natural transformation $\eta^u$ and for each 
natural transformation $\eta$, there is a unique $u$. 

To be clear, in this settings, $\C$ is some category, $F$ is a functor from $\C$ to $\Set$, $\Hom(A, -)$ as defined earlier is 
also a functor from $\C$ to $\Set$. $A, X, Y$ are objects in $\C$ and $f$ is an arrow from $X$ to $Y$ in $\C$.

Let's go back to the natural transformation definition above and put it in this context.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{yoneda_nattrans.png}
\end{figure}

Now this diagram should applies to any $X$, so we choose $X = A$. This will give us the following diagram

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{yoneda_nattrans2.png}
\end{figure}

Notice that a natural transformation is the one making this diagram commute. We only need to care about the one on the right so 
let's just highlight that like this.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{yoneda_set.png}
\end{figure}

On the right, we need that for any $u \in F(A)$, the corresponding element in $F(Y)$ needs to be $F(f)(u)$. On the left, 
we know that $id \in \Hom(A, A)$ and the corresponding element in $\Hom(A, Y)$ is $\Hom(A, f) (id) = f$.

There is nothing stopping us from combining the left and the right. So one legal definition of $\eta$ is the following:
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{yoneda_def.png}
\end{figure}
Which is that $\eta^u_X(f) = F(f)(u)$

This shows that for each $u$ we can define a natural transformation $\eta^u$. 
Then for the other direction, if we have a natural transformation, $\eta$,
we can also evaluate that at $\eta_A(id)$ to get the corresponding element in $F(A)$.

The conclusion is that 
$\Nattran(\Hom(A, -), F) \isom F(A)$
\rem{}{
  By repeating the same argument with contravariant functor, one can get
  \[ \Nattran(\Hom(-, A), F) \isom F(A) \] for a contravariant functor $F$.
}

\subsection{Implications}
Now is the point where my math knowledge is not enough to understand all the examples. 
The main idea is that all of the information in $A$ is captured by the functor $\Hom(A, -)$.
The object itself doesn't have any information outside of the relationship from the object to other objects.














\newpage
\section{For Programmers}
For programmers, I recommend the book \textbf{Category Theory for Programmers} by Bartosz Milewski. It is an easy enough read. 
Some of the content here will be based on the book. 
I'm not trying to replace that (as it's impossible to) but this section will be mainly my intepretation, i.e. can be wrong, 
and would be more like a note / summary on how I understand things.

In context of programming. The \textit{only (for now)} category we care about is the category of types, write $\Type$. 
The objects of $\Type$ are all posible types such as \code{bool}, \code{int}, or \code{char} but also includes more complex types 
such as \code{list<int>}.

Type is like set as it holds multiple possible values. \code{bool} can be thought of as a set $\set{\code{true}, \code{false}}$ and \code{int}
can be thought of as the set of all integers for example.

The arrow in the category of type is all the functions from one type to another. For example a function $\code{isPrime}$ is an arrow from 
\code{int} to \code{bool} or a function \code{square} is an arrow from \code{int} to \code{int}. 
However, function here is refered to in the mathematical sense. It cannot have any side effect. 
i.e. not modifying anything outside of the function scope. We call these functions pure.

Confusingly or not, a function type like \code{int $\to$ bool} is a type, therefore is an object. 
However, a member of \code{int $\to$ bool} such as \code{isPrime} is an arrow. 
This is similar to \Set as a set of functions is an object while a function is an arrow.

\subsection{Functor}
Since we only care about the category of type. The \textit{only, (for now),} functor we care about is the functor from \Type to \Type.
Therefore, in this section all functor will be from \Type to \Type (as category) and we only need to say 2 things about a functor: 
how it maps the objects (a type) and how it maps the arrows (a function).
Obviously there is an identity functor, but there are many more.

\begin{itemize}
  \item \code{optional} is a functor (from \Type to \Type). 
    \begin{verbatim}
      template<typename T>
      class optional<T> {
        bool has_value = false;
        T value;
      };
    \end{verbatim}
    It send a type \code{T} to a new type \code{optional<T>}. 
    For each arrow $f: T \to S$, we have corresponding $\code{optional<$f$>}:\code{optional<$T$>} \to \code{optional<$S$>}$.
    such that it operates on the underlying value. We can define the function as 
    \begin{verbatim}
      auto optional_map (Function f) {
        return [](optional<T> o) {
          if (!o.has_value) return optional<S> {false, {}};
          return optional<S> {true, f(o.value)};
        };
      }
    \end{verbatim}
    A bit ugly to try to fit this to C++ (I'm aware it will not compile).
  \item \code{list} is another example. 
    For each function \code{f: T $\to$ S} we have an arrow 
    \code{list<T> $\to$ list<S>} that does the same thing to every element in the list.
\end{itemize}

\end{document}
